第一部分（C++基础），部分内容取自：
https://blog.csdn.net/gettogetto/article/details/65628982
第一部分、C++基础


第二章：变量和基本类型
2.1、基本内置类型：

（1）算数类型：（bool 、 void 、int 、 short 、 long 、 double 、  char 、 float 、 undefined ）

（2）有符号及无符号

    内置类型的机器实现：地址表示比特串开始位置，类型决定了数据所占的比特位数及如何解释其内容
    未定义（undefined）：引发难以追踪的运行时的错误、安全问题、移植性问题
    有无符号类型混用：表达式中同时包含带符号和无符号类型，带符号数会自动转为无符号数
    整型字面值：十进制字面值默认为带符号数，是int/long/long long 中能容纳其值且尺寸最小。八进制（0开头）和十六进制（0x开头）则是int/unsigned int/unsigned long/long long/unsigned long long中尺寸最小者
    字符串字面值：编译器在每个字符串结尾添加空字符'\0’（算大小）
    字符前缀与类型：u（char16_t），U（char32_t），L（wchar_t），u8（char）
    泛化的转义序列：\x后跟十六进制数字，或\后跟1到3位八进制数字，可像普通字符一样使用

2.2、变量（初始化、定义、声明）

    列表初始化：使用花括号初始化，当存在丢失信息风险时编译器将报错，而使用()可以执行但可能发生信息丢失
    初始化：定义在任何函数之外的变量被初始化为0，每个类决定各自的初始化对象方式。而定义在函数体内部的内置变量类型将不初始化，试图访问未初始化的值将引发未定义行为
    定义：负责创建与名字关联的实体，并申请存储空间和赋初始值
    声明：规定变量的类型和名字，只声明不定义可在变量名前添加extern并不显式初始化，包含显式初始化即为定义

2.3、复合类型（引用、指针）

    引用：为对象起的别名，定义时必须初始化，不是对象，不可定义引用的引用
    指针：指向某个对象，定义时无需赋值，本身就是对象，对指针使用解引用符*可访问该对象
    指针值状态：指向一个对象、指向对象的下一个紧邻空间位置、空指针、无效指针（访问或拷贝都会出错）
    空指针（nullptr）：不指向任何对象，可以转换成任何其他的指针类型
    初始化指针：建议用已定义对象或nullptr或0初始化所有指针，把任何int型变量（即使值为0）赋值给指针是错误的
    void*指针：可存放任意对象的地址，但不能直接操作其所指对象
    引用／指针类型匹配：除两种特例（const可绑定非const，基类可绑定派生类）外，指针和引用的类型都需要与之绑定的对象严格匹配
    复合类型判断：从右向左阅读复杂的指针或引用的声明语句，离变量名越近的符号对变量的类型有越直接的影响
    多文件共享const：不管声明还是定义都要添加关键字extern
    初始化对const的引用：允许任何表达式作为初始值，只要该表达式结果可以转化为引用类型的临时量对象
    指向常量的指针：自觉不去改变所指对象的值，而该对象若不是常量对象则其值通过其他方式改变

2.4、const限定符

    const指针：必须初始化且不能修改，书写上直接在变量名之前，表示不变的是指针本身而非指针指向的对象
    顶层／底层const：顶层const表示本身是常量，底层const表示绑定的对象是常量；执行拷贝操作时，拷入拷出对象必须具有相同的底层const资格，或能够强制转换
    常量表达式：数据类型和初始值都需要是常量类型，值不会改变并在编译过程就能得到计算结果
    constexpr变量：一定是常量，必须用常量表达式（字面值类型，包括算术类型、引用、指针）或constexpr函数（足够简单编译时可计算结果）初始化
    constexpr指针：初始值是nullptr或0，或存储于某个固定地址中的对象
    指针、常量与类型别名：typedef char *pstring; const pstring cstr = 0;，与const char *cstr不等价，前者的cstr是指向char的常量指针，后者中cstr是指向常量char的指针

2.5、处理类型（auto、decltype）

    类型说明符auto：让编译器通过初始值推算变量类型，并赋诸该值；忽略顶层const，保留底层const
    类型指示符decltype：让编译器通过初始值推算变量类型，但不用该初始值赋值；包含顶层const，解引用、(())、赋值产生的引用都会判为引用类型
    预处理器：在编译前执行的一段程序，功能有替换#include的头文件，以及头文件保护符避免重复定义实体
    预处理变量：#define将一个名字设置为预处理变量，#ifndef及#ifdef则判断名字是否已被定义过，无视作用域规则

2.6、自定义数据结构（自己定义类）




第三章：字符串、向量和数组
3.1、字符串

    using声明：每个using声明引入命名空间的一个成员；头文件中的代码一般不应使用using声明
    string初始化：用数字和字符初始化，则string对象内容是将给定字符连续重复给定次数得到的序列

3.2、向量

    3.3、数组
    vector比较：当元素的值可比较时，按照字典顺序进行

3.4、迭代器的介绍


第四章：表达式

    左值右值：左值用的是对象的身份，右值用的是对象的值
    整数相除：商向0取整；取余时m%(-n)=m%(n)，-m%n=-(m%n)
    真值测试：比较运算中除非比较对象是bool型，否则不使用布尔字面值
    复合赋值运算符：只求值1次，普通运算符需要2次（右边表达式和赋值）
    移位运算符：右侧的移动位数必须非负且小于结果的位数；移出位被舍弃，符号位视机器而定
    sizeof运算符：可使用作用域来获取类成员大小，可使用无效的指针获取指针指向的对象所占空间，不会把数组当指针处理，对string或vector返回固定部分的大小；sizeof的返回值是常量表达式


第五章：语句
5.1、条件语句（if 、 switch）

1、switch语句：对括号内表达式求值转换为整数类型，然后与case后的每个常量表达式比较

2、default标签：当其他case都不满足时执行，位置自由，若为空也必须跟上一个空语句（ ;）或空块（{}）
5.2、迭代语句（while 、 for 、 do while）

1、范围for语句：语法形式是for (declaration: expression) statement；expression表示一个可以返回迭代器的begin()和end()的序列，不允许增删容器元素改变范围for中预存的end()值
5.3、跳转语句（break、continue、goto）

1、控制流跳转：在switch和goto中，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置
5.4、try 语句块和异常处理（throw、try）

异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括市区数据库连接以及遇到意外输入等。处理反常行为可能是涉及所有系统最难的一部分。

1、异常：throw引发异常，try中跑出的异常通过会被某个catch处理，在throw与catch间通过异常类传递信息

2、寻找异常处理代码：寻找异常处理代码的过程与函数调用相反，逐层回退直到找到适当类型的catch子句；若最终未找到则会转到terminate的标准库函数，全无try语句的程序会直接调用terminate

3、异常安全：确保对象有效，资源无泄漏，程序处于合理状态，等等

4、异常类：头文件exception中的exception类、stdexcept中定义了几种常见的异常类、new中的bad_alloc、type_info中的bad_cast

5、异常类初始化：exception、bad_alloc、bad_cast只允许默认初始化，what()返回编译器决定的异常信息；标准异常类必须使用string或C风格字符串初始化，what()返回该串




第六章：函数
6.1、函数基础
6.2、参数传递
6.3、返回类型和return语句
6.4、函数重载

    函数参数：实参是函数中形参的初始值，存在对应关系，但并没有规定实参的求值顺序
    局部静态对象：不同于只存在于块执行期间的自动对象，局部静态对象直到程序终止才被销毁；没有显式初始值时会执行值初始化
    函数声明：函数可以只能声明一次，但可以定义多次，如果一个函数永远不会被用到，可以只声明不定义
    const参数：实参初始化形参时会忽略顶层const，所以有无顶层const版本等价，都定义则属于重复定义
    数组实参：不允许拷贝数组，传递数组时实际上是传递指向首元素的指针；不同大小的数组是不同类型；若形参是引用，数组不会转换为指针
    传多维数组：数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略
    initializer_list：实参数量未知但类型都相同，initializer_list可作形参；提供的操作类似容器，但对象中的元素永远是常量
    省略符形参：出现在形参列表的最后一个位置，形式为f(…)或f(t,…)；大多类类型对象传递给省略符形参时无法正常拷贝
    返回引用：不要返回局部对象的引用或指针，调用一个返回引用的函数得到左值
    列表初始化返回值：函数可以返回花括号包围的值的列表；若返回为内置类型，则花括号内至多一个值，而且所占空间不应大于目标类型空间
    main的返回值：控制到了main的结尾仍无return语句，编译器隐式插入return 0;；头文件cstdlib中定义了预处理变量EXIT_FAILURE和EXIT_SUCCESS表示成败
    返回数组指针：形如Type (*function(parameter_list))[dimension]，函数返回类型是指向大小为dimension的数组的指针
    尾置返回类型：形如auto function(parameter_list) -> Type (*)[dimension];
    decltype确定返回类型：把左值转换为引用；由于decltype不负责把数组或函数类型转换为对应指针，所以函数声明时要加一个星号
    main函数：不能调用自己，不能重载
    const_cast和重载：常用const_cast修改const参数属性的性质，将const和非const版本的重载函数关联
    重载与作用域：名字查找发生在类型检查前，所以在不同作用域无法重载函数名，且内层将隐藏外层声明的同名函数
    形参默认值：被赋予了默认值的形参，后面所有形参都必须有默认值；在给定的作用域中一个形参只能被赋予一次默认值；可多次声明函数给不同形参赋予默认值
    内联函数：一般只有当函数规模小、流程直接、无递归时，内联函数的请求才会被编译器接受
    constexpr函数：能用于常量表达式的函数，但返回值可以是非常量；返回和形参类型都是字面值类型，函数只执行一句return；被隐式指定为内联函数；
    内联定义：和其他函数不同，内联和constexpr函数可以多次定义，但每次必须完全一致，通常定义在头文件中
    预处理宏assert：根据提供的表达式判断是否要输出错误信息并终止程序，可定义预处理变量NDEBUG禁用assert的效果
    NDEBUG：可在#ifndef NDEBUG和#endif之间编写自己的调试代码；有5个编译器预定义的名字变量__func__/__FILE__/__LINE__/__TIME__/__DATE__，用于输出调试信息
    函数匹配：先选择在调用点可用的同名候选函数，再找到参数数量相等且类型相同或可强制转换的可行函数，再寻找其中最佳匹配的函数
    最佳匹配：每个实参的匹配都不劣于其他可行函数，且至少有一个优于其他；若找不到最佳匹配则报二义性错误
    实参类型转化优先级：精确匹配>const转换>类型提升>算术类型或指针转换>类类型转换
    函数指针：声明指向一个函数的指针，只需要用指针替换函数名；将函数名当作值使用时会自动转换成指针
    重载函数的指针：指针类型必须与重载函数中的某一个精确匹配
    函数指针形参：函数声明中，若形参是函数类型，则它会自动转换成指向函数的指针


第七章：类
7.1、定义抽象数据类型
7.2、访问控制和封装
7.3、类的其他特性
7.4、类的作用域

    数据抽象：定义数据成员和函数成员，抽象数据类型依赖封装
    封装：分离接口（用户所能执行的操作）和实现（数据成员、实现接口的函数体、私有函数）
    成员函数：声明必须在类内部，但定义可在类内或外，定义在类内部的函数是隐式的inline函数
    this：指向类类型非常量版本的常量指针，所以不能在常量类对象上调用普通成员函数
    常量成员函数：参数列表后带const的函数叫常量成员函数，它可将this设置为指向常量的指针，使得常量对象可访问常量成员函数，但不可写入新值；若以引用形式返回*this，则返回类型是常量引用
    合成的默认构造函数：会尽可能使用类内初始值初始化数据成员，当类不存在任何构造函数时编译器创建的默认构造函数；既需要其他形式又需要合成的默认构造函数，可在默认构造函数的参数列表后面加上= default
    类的动态内存：当类需要分配类对象之外的资源时，合成的版本常常会失效；需要动态内存的类应该使用vector或string对象管理存储空间，避免分配和释放内存带来的复杂性
    class和struct：唯一区别是默认的访问权限，class为private，struct为public
    友元：允许其他类或函数访问非公有成员，则可在类的开头用friend关键字将其声明为友元；友元的声明仅仅限定了权限，可在真正的函数声明之后；友元函数可以定义在类的内部，但在类的外部仍然需要提供相应的声明使得函数可见
    可变数据成员：添加mutable关键字的数据成员，即使在const成员函数中，依旧可以被改变
    类内初始值：必须使用符号或花括号的直接初始化形式
    重载const：根据是否是常量对象，决定调用是否是常量版本的成员函数
    类的声明：仅声明不定义叫做前向声明：类在声明之后、定义完成之前是不完全类型，可以定义其指针或引用，作为函数的参数或返回值；只有当类全部完成后类才算被定义，所以类的成员中不能包含自己，但可以出现指针或引用
    类的定义：编译所有成员的声明之后才会编译函数体
    类型名的定义：内层作用域可以重新定义外层作用域的名字，但若外层作用域中的某个名字表示类型，则类中不能再重新定义该名字
    访问类成员：使用this->或类名::可强制访问类成员，无视作用域的名字查找规则；无类名加::表示全局对象
    成员初始化：若成员是const、引用、无默认构造函数的类，必须通过初始值列表将其初始化
    初始化顺序：与类中定义的顺序一致，不受初始值列表中顺序影响
    默认构造函数：当对象被默认初始化或值初始化时，自动执行默认构造函数；不那么明显的一种情况是类的某些数据成员缺少默认构造函数
    默认初始化场景：无任何初始值定义非静态变量或数组，本身含有类成员且使用合成的默认构造函数，类类型成员没有在构造函数初始值列表中显式初始化
    值初始化：初始值数量小于被初始化的数组大小，不使用初始值定义局部静态变量，通过T()表达式显式请求值初始化
    默认构造对象：使用默认构造函数定义对象的格式为类名+对象名，无之后空的圆括号对，否则将定义为函数而非对象
    类类型转换：构造函数只接受一个实参，则其定义了一种从构造函数的参数类型到类类型的隐式转换规则；编译器只会自动执行一步类型转换
    显式构造函数：在类内添加explicit关键字的构造函数只能用于直接初始化，抑制隐式转换；编译器不会在自动转换过程中使用它，但可用于显式的强制转化
    聚合类：所有成员public、未定义构造函数、无类内初始值、无基类或virtual函数；使用花括号初始化，花括号内的初始值顺序与声明顺序一致
    字面值常量类：数据成员都是字面值类型的聚合类；或数据成员都是字面值类型、至少含有一个constexpr构造函数、类内初始值是常量表达式或拥有自己的constexpr构造函数、使用析构函数的默认定义
    constexpr构造函数：为保证构造函数的不包含返回语句，和constexpr函数唯一可执行语句即返回函数，其函数体一般为空
    静态成员：独立于任何对象之外，不包含this指针；静态成员函数不能声明为const，也不能在内部使用this指针
    静态数据成员：必须在类的外部定义和初始化，方式和类外部定义成员函数类似；若静态数据成员为constrexpr类型，且其只限于编译器替换值的使用场景，则可以在类内定义，否则必须在类外再重新定义
    静态成员的优势：类内可包含自身类型的静态数据成员，但普通成员只能是指针或引用；静态成员可以作为默认实参，非静态数据成员的值属于对象的一部分，不能作为默认实参



第二部分、C++标准库


第七章：类
7.1、成员函数

（1）this

（2）构造函数

（3）重载成员函数

（4）领成员成为内联函数
7.2、访问控制及其封装

class而非struct，public 和private

（1）友元

A想访问B，
7.3、类的其他特性




7.4、类的作用域

第八章：IO库
8.1、IO类

    （iostream流、fstream文件、sstream从string）

     "如果程序崩溃，输出缓冲区不会被刷新"
8.2、文件输入输出

（1）文件模式

     以out的方式打开文件会丢弃掉已有的数据

     每次调用open时都要确定文件模式
8.3、string 流



第九章：顺序容器
9.1、容器库概览


9.2、顺序容器操作


9.3、vector对象时如何增长的


9.4、额外的String操作


第十章：泛型算法
10.1、初识泛型算法

（1）标准库容器定义了很少的操作（添加、删除元素，访问首尾元素等），有更多的操作（如查找特定元素、重排元素等）需要通过算法实现。迭代器令算法不依赖于容器，但算法依赖于元素类型的操作

（2）算法：find、count、accumulate、equal、fill、replace、sort、unique、stable_sort、for_each、transform
10.2、定制操作

（1）lambda表达式：


10.3、迭代器

（1）插入迭代器

（2）流迭代器

（3）反向迭代器

（4）移动迭代器
10.4、泛型算法结构（待查看，看讲不讲）

（1）

（2）

（3）

（4）


第十一章：关联容器
11.1、关联容器概述及其操作

（1）关联容器支持高效的关键字查找和访问。

主要的关联容器是：map 和 set ，map是键值对，而set是光只有键

关联容器不支持顺序容器的操作，原因我们通过键值来访问，这些操作对关联容器没有意义。

关联容器的迭代器都是双向的。

（2）使用map：


（3）使用set：


11.2、无序容器

c++11定义了新的4个无序关联容器，这些容器不是使用比较运算符来组织元素的，而是使用一个hash函数和关键字类型==运算符。

（1）unordered_map：用hash函数组织的map 
（2）unordered_set：用hash函数组织的set 
（3）unordered_multimap：hash组织的map：关键字可重复出现
（4）unordered_multiset：hash组织的set：关键字可重复出现



第十二章：动态内存
12.1、动态内存与智能指针
12.2、动态数组
12.3、使用标准库：文本查询程序


第三部分、类设计者的工具
第十三章：拷贝控制
12.1、
12.2、
12.3、


第十四章：拷贝控制
12.1、
12.2、
12.3、


第十五章：面向对象的程序设计
OOP概述：（面向对象程序设计Object-oriented Programming）

核心思想：数据抽象、继承和动态绑定

（1）数据抽象：类的接口与实现分离（见第七章）

（2）继承：

（3）动态绑定：

          分解为四个概念：对象的静态类型、对象的动态类型、静态绑定、动态绑定

          动静态类型这两个概念一般发生在基类和派生类之间

1、对象的静态类型（static type）：就是它在程序中被声明时所采用的类型（或理解为类型指针或引用的字面类型），在编译期确定；

2、对象的动态类型（dynamic type）：是指“目前所指对象的类型”（或理解为类型指针或引用的实际类型），在运行期确定；

           动静态绑定只有当编译器产生的代码直到运行时才能确定应该调用哪个版本的函数

3、静态绑定（statically bound）：又名前期绑定（eraly binding），绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；

4、动态绑定（dynamically bound）：又名后期绑定（late binding），绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；


15.1、定义基类和派生类

（1）基类对函数将会分成两种：（基类的函数被派生类覆盖）（派生类直接继承不进行覆盖）

（2）基类通过对其成员函数加上关键字virtual，使得该函数执行动态绑定，
15.2、虚函数

1.只有当我们使用基类的引用或指针调用一个虚函数时会执行动态绑定，动态绑定的对象依赖于绑定的对象；
2.派生类可省略virtual；

final关键字：定义了final关键字的函数，之后任何尝试覆盖该函数的操作都会引发错误


15.3、抽象基类


15.4、访问控制与继承

（public 、 private 、 protected ）
15.5、继承中的类作用域
15.6、构造函数与拷贝控制
15.7、容器与继承
15.8、文本查询程序再探



第十六章：模板与泛型编程
16.1、定义模板

1、函数模板

模板成宿应该尽量减少对实参类型的要求。

（1）类型模板参数：

template <typename T, class U>
void test(T i, U j)
{
}

（2）非类型模板参数：

表示一个值，而非类型

template <unsigned M, unsigned N>
int compare(const char (&p1)[M], const char(&p2)[N])
{
    return strcmp(p1, p2);
}

compare("test", "abc");    // test被转换成M=5，abc被转换成N=4 p1就是test数组的引用，p2就是abc数组的引用

实例出如下版本：

int compare(const char (&p1)[5],const char (&p2)[4])

算上 \0 字符串结束标志

（3）编译参数模板会在这三个阶段出现错误报告

*、编译模板本身时：检查语法是否有错误

*、编译器遇到模板使用时：参数数目、参数类型是否匹配

*、模板实例化时：检查类型是否有实例化

Sales_data data1,data2;

cout << compare(data1,data2)<<endl ; //错误，  Sales_data 未定义

（先得实例化了类型才能使用）


2、类模板

编译器从模板类中实例化出一个类时，它会重写类模板，将模板参数T的每个实例替换为给定的模板实例。

一个类模板的成员函数只有当程序用到它时才进行实例化,所以下面的T，虽然是在一个类中，但是都代表不同的类型。

template <typename T>
class test
{
public:
    test();
    test<T>& operator=(const test<T>& t) { this->m_vec = t.m_vec; return *this; }
    test copy(const test& t) { test tmp; tmp.m_vec = t.m_vec; return tmp; }    // 在类的内部可以简化使用类名

    template <typename U>    // 可以嵌套其他的模板函数
    U add(U i)
    {
        return i++;
    }

    std::vector<T> m_vec;   
};

template <typename T>    // 定义可以在类外
test<T>::test()
{
}

test<std::string> t;
test<std::string> t1 = t;
t.add(1);    // 返回2

实例化test 时，

test<string> t      ---->         std::vector<string>  t;

test<int> t           ---->         std::vector<int>  t;


（2）、类模板成员函数

（3）、类模板成员函数的实例化


3、模板参数


4、成员模板


5、控制实例化


6、效率与灵活性


16.2、模板实参推断

编译器利用调用中的函数实参来确定其模板参数，从函数实参来确定模板实参的过程被称为模板实参推断。

1、类型转换与模板类型参数

2、
16.3、重载与模板


16.4、可变参数模板


16.5、模板特列化





第四部分、高级主题
第十七章：标准库特殊设施
17.1、定义模板
17.2、定义模板
17.3、正则表达式


17.4、定义模板
第十八章：用于大型程序的工具

大规模应用程序的特殊要求包括：

(1)在独立开发的子系统之间协同处理错误的能力

(2)使用各种库（可能包含独立开发的库）进行协同开发的能力

(3)对比较复杂的应用概念建模的能力
18.1、异常处理


18.1、命名空间
18.1、多重继承与虚继承


第十六章：特殊工具和技术
19.1、定义模板
19.1、定义模板
19.1、定义模板
19.1、定义模板








